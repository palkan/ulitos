<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<title>.eunit/ulitos_file.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/palkan/Dev/erly/deps/ulitos/.eunit/ulitos_file.erl by COVER 2013-12-12 at 15:48:39

****************************************************************************

        |  -module(ulitos_file).
        |  -author("palkan").
        |  
        |  -export([recursively_list_dir/1,
        |    recursively_list_dir/2,
        |    recursively_del_dir/1,
        |    dir_traversal/2,
        |    dir_traversal/3]).
        |  
        |  
        |  % @type name() = string() | atom() | binary().
        |  -type name() :: string() | atom() | binary().
        |  
        |  
        |  
        |  
        |  %% API
        |  
        |  % @spec (Dir::name()) -&gt; {ok, [string()]} | {error, atom()}
        |  % @equiv recursively_list_dir(Dir, false)
        |  %
        |  % @doc Lists all the files in a directory and recursively in all its
        |  % sub directories. Returns {ok, Paths} if successful. Otherwise,
        |  % it returns {error, Reason}. Paths is a list of Paths of all the
        |  % files and directories in the input directory's subtree. The paths are not
        |  % sorted in any order.
        |  
        |  -spec recursively_list_dir(Dir::name()) -&gt;
        |    {ok, [string()]} | {error, atom()}.
        |  
        |  recursively_list_dir(Dir) -&gt;
     7..|    recursively_list_dir(Dir, false). % default value of FilesOnly is false
        |  
        |  
        |  
        |  
        |  % @spec (Dir::name(), FilesOnly::boolean()) -&gt; {ok, [string()]} |
        |  %                                                   {error, atom()}
        |  %
        |  % @doc Lists all the files in a directory and recursively in all its
        |  % sub directories. Returns {ok, Paths} if successful. Otherwise,
        |  % it returns {error, Reason}. If FilesOnly is false, Paths is a list of paths
        |  % of all the files &lt;b&gt;and directories&lt;/b&gt; in the input directory's subtree.
        |  % If FilesOnly is true, Paths is a list of paths of only the files in the
        |  % input directory's subtree. The paths are not sorted in any order.
        |  
        |  -spec recursively_list_dir(Dir::name(), FilesOnly::boolean()) -&gt;
        |    {ok, [string()]} | {error, atom()}.
        |  
        |  recursively_list_dir(Dir, FilesOnly) -&gt;
     8..|    case filelib:is_file(Dir) of
        |      true -&gt;
     6..|        case filelib:is_dir(Dir) of
     4..|          true -&gt; {ok, dir_traversal([Dir], fun(Path,Acc) -&gt; [Path|Acc] end, FilesOnly)};
     2..|          false -&gt; {error, enotdir}
        |        end;
     2..|      false -&gt; {error, enoent}
        |    end.
        |  
        |  
        |  % @spec (Dir::name()) -&gt; ok | {error, atom()}
        |  %
        |  % @doc Delete all files and directories within Dir (and Dir itself).
        |  % Return {error, Reason} if Dir doesn't exist or is not directory.
        |  
        |  -spec recursively_del_dir(Dir::name()) -&gt;
        |    ok | {error, atom()}.
        |  
        |  
        |  recursively_del_dir(Dir) -&gt;
     3..|    case recursively_list_dir(Dir) of
     1..|      {ok,List} -&gt; del_paths(List);
     2..|      Error -&gt; Error
        |    end.
        |  
        |  
        |  % @spec (Dir::name(),Fun::function()) -&gt; {ok, Result::list()} | {error, atom()}
        |  % @equiv dir_traversal(Dir,Fun,false)
        |  %
        |  % @doc Traverse through directory from top to bottom and execute Fun on each path.
        |  %% Fun must have signature fun(Path::string(), Acc:list()) -&gt; list().
        |  
        |  -spec dir_traversal(Dir::name(),Fun::function()) -&gt;
        |  {ok,Result::list()} | {error, atom()}.
        |  
<font color=red>     0..|  dir_traversal(Dir,Fun) -&gt; dir_traversal(Dir,Fun,false).</font>
        |  
        |  % @spec (Dir::name(),Fun::function(),FilesOnly::boolean()) -&gt; {ok, Result::list()} | {error, atom()}
        |  % @equiv dir_traversal(Dir,Fun,false)
        |  %
        |  % @doc Traverse through directory from top to bottom and execute Fun on each path.
        |  % If FilesOnly is true, then affects only files.
        |  % Fun must have signature fun(Path::string(), Acc:list()) -&gt; list().
        |  
        |  -spec dir_traversal(Dir::name(),Fun::function(),FilesOnly::boolean()) -&gt;
        |    {ok,Result::list()} | {error, atom()}.
        |  
        |  dir_traversal(Dir,Fun,FilesOnly) -&gt;
     4..|    dir_traversal(Dir,Fun,FilesOnly,[]).
        |  
        |  %% Internal
        |  
    15..|  dir_traversal([], _Fun, _FilesOnly, Acc) -&gt; Acc;
        |  dir_traversal([Path|Paths], Fun, FilesOnly, Acc) -&gt;
    14..|    dir_traversal(Paths, Fun, FilesOnly,
        |      case filelib:is_dir(Path) of
     3..|        false -&gt; Fun(Path,Acc);
        |        true -&gt;
    11..|          {ok, Listing} = file:list_dir(Path),
    11..|          SubPaths = [filename:join(Path, Name) || Name &lt;- Listing],
    11..|          dir_traversal(SubPaths, Fun, FilesOnly,
        |            case FilesOnly of
     2..|              true -&gt; Acc;
     9..|              false -&gt; Fun(Path,Acc)
        |            end)
        |      end).
        |  
        |  
     1..|  del_paths([]) -&gt; ok;
        |  
        |  del_paths([Path|Paths]) -&gt;
     4..|    case filelib:is_dir(Path) of
     3..|      true -&gt; file:del_dir(Path);
     1..|      false -&gt; file:delete(Path)
        |    end,
     4..|    del_paths(Paths).
        |  
        |  
        |  
        |  
        |  %% Tests
        |  
        |  -ifdef(TEST).
        |  -include_lib("eunit/include/eunit.hrl").
        |  
        |  non_existing_file_returns_error_test() -&gt;
     1..|    ?assertEqual({error, enoent},
     1..|      recursively_list_dir("UnUSuAalfIlEnaMe")),
     1..|    ok.
        |  
        |  non_directory_input_returns_error_test() -&gt;
     1..|    file:write_file("f1.test", &lt;&lt;"temp test file"&gt;&gt;),
     1..|    ?assertEqual({error, enotdir},
     1..|      recursively_list_dir("f1.test")),
     1..|    file:delete("f1.test"),
     1..|    ok.
        |  
        |  list_test_() -&gt;
     1..|    {"List dir tests",
        |      {foreach,
        |        fun list_setup/0,
        |        fun list_cleanup/1,
        |        [
        |          fun list_simple_t/1,
        |          fun list_nofiles_t/1,
        |          fun list_filesonly_t/1
        |        ]
        |  
        |      }
        |    }.
        |  
        |  
        |  del_test_() -&gt;
     1..|    {"delete dir tests",
        |      {foreach,
        |        fun delete_setup/0,
        |        fun list_cleanup/1,
        |        [
        |          fun del_no_dir_t/1,
        |          fun del_simple_t/1
        |        ]
        |  
        |      }
        |    }.
        |  
        |  
        |  list_simple_t(_) -&gt;
     1..|    filelib:ensure_dir("a/b/c/"),
     1..|    file:write_file("a/b/f.test", &lt;&lt;"temp test file"&gt;&gt;),
     1..|    [?_assertEqual({ok, ["a/b/f.test","a/b/c","a/b","a"]},
     1..|      recursively_list_dir("a"))].
        |  
        |  list_nofiles_t(_) -&gt;
     1..|    filelib:ensure_dir("a/b/c/"),
     1..|    [?_assertEqual({ok, ["a/b/c", "a/b", "a"]},recursively_list_dir("a"))].
        |  
        |  list_filesonly_t(_) -&gt;
     1..|    filelib:ensure_dir("a/b/f.test"),
     1..|    file:write_file("a/b/f.test", &lt;&lt;"hello"&gt;&gt;),
     1..|    [?_assertEqual({ok, ["a/b/f.test"]},
     1..|      recursively_list_dir("a", true))].
        |  
        |  list_setup() -&gt;
     3..|    ok.
        |  
        |  list_cleanup(_) -&gt;
     5..|    file:delete("f1.test"),
     5..|    file:delete("a/b/f.test"),
     5..|    file:del_dir("a/b/c"),
     5..|    file:del_dir("a/b"),
     5..|    file:del_dir("a"),
     5..|    ok.
        |  
        |  del_no_dir_t(_) -&gt;
     1..|    [
     1..|      ?_assertEqual({error,enoent},recursively_del_dir("UnUSuAalfIlEnaMe")),
     1..|      ?_assertEqual({error,enotdir},recursively_del_dir("a/b/f.test"))
        |    ].
        |  
        |  del_simple_t(_) -&gt;
     1..|     [
     1..|      ?_assertEqual(ok,recursively_del_dir("a")),
     1..|      ?_assertNot(filelib:is_file("a/b"))
        |     ].
        |  
        |  
        |  delete_setup() -&gt;
     2..|    filelib:ensure_dir("a/b/c/"),
     2..|    file:write_file("a/b/f.test", &lt;&lt;"temp test file"&gt;&gt;),
     2..|    ok.
        |  
        |  -endif.
</pre>
</body>
</html>
